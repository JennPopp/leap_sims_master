#include "TTree.h"
#include "TFile.h"
#include "TLatex.h"
#include <string>
#include <vector>
#include <dirent.h>
#include <stdio.h>

using namespace std;

auto read_files(TString fname){
  //-------------000------00000------------0000----------0000000---
  // get files, ttrees and number of entries
  //-------------000------00000------------0000----------0000000---

  // get file of magnetic field parallel to polarization and propagation direction of incoming e-
  TFile *F0 = new TFile(fname);
  //pointer to ttree of sensor after magnet
  TTree *TTP0=(TTree*)F0->Get("bremssim2");
  //------------get number of entries ----------------
  const int Nruns = TTP0->GetEntries();


  //-------------000------00000------------0000----------0000000---
  // create array with variables
  //-------------000------00000------------0000----------0000000---

  //create variables
  double E0; int Npart0;
  // create vector for each of them
  vector<double> Esum0;
  Esum0.reserve(Nruns);
  vector<int> NP0;
  NP0.reserve(Nruns);
  //pointer to branch
  TBranch *EsumBranch0;
  TBranch *NPBranch0;
  // connect the branches with the variables and create pointers to the branches
  TTP0->SetBranchAddress("Esum", &E0, &EsumBranch0);
  TTP0->SetBranchAddress("NP", &Npart0, &NPBranch0);
  // write entries in arrays
  for (int i=0;i<Nruns;++i){
    EsumBranch0->GetEntry(i);
    NPBranch0->GetEntry(i);
    Esum0.push_back(E0);
    NP0.push_back(Npart0);
  }
  F0->Close();
  delete F0;
return make_pair(Esum0, NP0);
}

auto get_fnames(const char* dname, string namepart){
  DIR *di;
  struct dirent *dir;
  vector<string> flist;
  string s1 ;
  di = opendir(dname); //specify the directory name
  if (di){
    while ((dir = readdir(di)) != NULL){
      s1=dir->d_name; // name of the current file
      if (s1.find(namepart) != std::string::npos) {  // if namepart is substring
          flist.push_back(s1);
      }
    }
    closedir(di);
  }
  return(flist);
}

void plot_Esum(vector<double> Esum0, vector<double> Esum1){
  //find minimum and maximum values of Esum vectors
  auto min_val0 = *std::min_element(Esum0.begin(),Esum0.end());
  auto max_val0 = *std::max_element(Esum0.begin(),Esum0.end());
  auto min_val1 = *std::min_element(Esum1.begin(),Esum1.end());
  auto max_val1 = *std::max_element(Esum1.begin(),Esum1.end());
  // create canvas for plot
  auto c1 = new TCanvas("c1","plot_Esum",200,10,700,500);
  gStyle->SetTitleSize(0.05,"xyz");
  gStyle->SetTitleSize(0.09,"t");
  c1->SetRightMargin(0.09);
  c1->SetLeftMargin(0.15);
  c1->SetBottomMargin(0.15);

  //create histograms
  THStack *hs = new THStack("hs","");
  TH1D *h0 = new TH1D("h0", "Esum0", 30, min_val0, max_val0 );
  TH1D *h1 = new TH1D("h1", "Esum1", 30, min_val1, max_val1 );
  //fill them
  for (int i=0; i<size(Esum0); i++){
    h0->Fill(Esum0[i]);
    h1->Fill(Esum1[i]);
  }
  //Set attributes
  h0->SetLineWidth(4);
  h1->SetLineColor(46);
  h1->SetLineWidth(4);
  // ad them to the Stack
  hs->Add(h0);
  hs->Add(h1);

  h0->GetXaxis()->SetLabelSize(0.05);
  h0->GetYaxis()->SetLabelSize(0.05);
  //draw them
  hs->Draw();

  //gStyle->SetTitleSize(0.2);
  //gStyle->SetTitleFont(32,"t");

  hs->SetTitle("Sum of Photon Energies Generated by an Electron Bunch; Energy / MeV; Number of e- Bunches");

  //draw legend
  auto legend = new TLegend(0.3,0.75,0.7,0.9);
   //legend->SetHeader("The Legend Title","C"); // option "C" allows to center the header
   legend->AddEntry(h0,"Parallel Polarization","l");
   legend->AddEntry(h1,"Antiparallel Polarization","l");
   legend->Draw();
c1->SaveAs("./plots/Esum_distr.eps");
c1->SaveAs("./plots/Esum_distr.pdf");
}

auto StringVec2DoubleVec(const vector<string>& stringVec){
  vector<double> doubleVec(stringVec.size());
  transform(stringVec.begin(), stringVec.end(), doubleVec.begin(),
            [](const string& val){return stod(val);});
  return doubleVec;
}

void plot_corerun( vector<string> E,  vector<string> core,
                   vector<string> conv,  string NBunch,
                   vector<double> meanEsum0, vector<double> meanEsum1,
                   vector<double> ErrE0,  vector<double> ErrE1,
                   vector<double> Asy,  vector<double> ErrAsy,
                   vector<double> rate,  vector<double> ErrRate){
  //------ooooooo-------0000000--------oooooo-------0000000------oooooo---------
  //          Draw Asymmetry and rate
  //------ooooooo-------0000000--------oooooo-------0000000------oooooo---------
  //Get double vector from string vector
  auto coref=StringVec2DoubleVec(core);
  int N=size(coref);
  gStyle->SetGridColor(17);
  gStyle->SetEndErrorSize(4);
  //gStyle->SetTitleSize(0.04,"xyz");
  gStyle->SetTitleSize(0.05,"xyz");

  //create canvas and pad
  auto c1 = new TCanvas("c1","gerrors2",200,10,750,525);
  TPad *pad = new TPad("pad","",0,0,1,1);
  pad->SetFillColor(0);
  pad->SetGrid();
  pad->Draw();
  pad->cd();

  // draw a frame to define the range
  auto *hr = pad->DrawFrame(*min_element(coref.begin(),coref.end())-10,
                            0,
                            *max_element(coref.begin(),coref.end())+10,
                            *max_element(Asy.begin(),Asy.end())*1.1);
  TString title=string("N_{e}/Bunch=")+NBunch+", E_{beam}="+E[0]+"MeV, conv="+conv[0]+ "mm";
  hr->SetTitle(title);
  hr->SetXTitle("Thickness of Magnet Core / mm");
  hr->SetYTitle("Transmission Asymmetry /%");
  hr->GetXaxis()->SetLabelSize(0.04);
  hr->GetYaxis()->SetLabelSize(0.04);
  pad->GetFrame()->SetFillColor(0);
  pad->GetFrame()->SetBorderSize(12);
  // first graph for the asymmetry
  auto gr1 = new TGraphErrors(N,coref.data(),Asy.data(),0,ErrAsy.data());
  gr1->SetTitle(title);
  gr1->SetMarkerColor(4);
  gr1->SetMarkerStyle(21);
  gr1->SetMarkerSize(0.8);
  //gr1->SetLineWidth(2);
  gr1->Draw("LP");
  //create a transparent pad drawn on top of the main pad
  c1->cd();
  TPad *overlay = new TPad("overlay","",0,0,1,1);
  overlay->SetFillStyle(4000);
  overlay->SetFillColor(0);
  overlay->SetFrameFillStyle(4000);
  overlay->SetLogy();
  overlay->Draw();
  overlay->cd();
  // second graph for the mean number of photons per electron
  auto gr2 = new TGraphErrors(N,coref.data(),rate.data(),0,ErrRate.data());
  gr2->SetMarkerColor(kRed);
  gr2->SetMarkerStyle(20);
  gr2->SetMarkerSize(0.8);
  //gr2->SetLineWidth(2);
  gr2->SetName("gr2");
  Double_t xmin = pad->GetUxmin();
  Double_t ymin = *min_element(rate.begin(), rate.end()) *0.1;
  Double_t xmax = pad->GetUxmax();
  Double_t ymax =  *max_element(rate.begin(), rate.end()) * 1.1;
  TH1F *hframe = overlay->DrawFrame(xmin,ymin,xmax,ymax);
  hframe->GetYaxis()->SetTickLength(0);
  hframe->GetXaxis()->SetLabelOffset(99);
  hframe->GetYaxis()->SetLabelOffset(99);
  gr2->Draw("LP");

  //Draw an axis on the right side
  TGaxis *axis = new TGaxis(xmax,ymin,xmax, ymax,ymin,ymax,510,"G+L");
  axis->SetLineColor(kRed);
  axis->SetLabelColor(kRed);
  axis->SetLabelSize(0.04);
  axis->Draw();
  axis->SetTitle("N_{#gamma}/Bunch");
  axis->SetTitleSize(0.04);

  c1->SaveAs("./plots/core_run_Asy_rate.svg");
  c1->SaveAs("./plots/core_run_Asy_rate.pdf");

  //------ooooooo-------0000000--------oooooo-------0000000------oooooo---------
  //          Draw mean Energies
  //------ooooooo-------0000000--------oooooo-------0000000------oooooo---------
  auto c2 = new TCanvas("c2","meanEsum01",200,10,800,550);
  c2->SetGrid();
  c2->GetFrame()->SetBorderSize(12);
  c2->SetRightMargin(0.09);
  c2->SetLeftMargin(0.15);
  c2->SetBottomMargin(0.15);
vector<double> mEGeV0; mEGeV0.reserve(size(meanEsum0));
vector<double> ErrEGeV0; ErrEGeV0.reserve(size(meanEsum0));
for (int i=0; i<=size(meanEsum0); i++)
{
  mEGeV0.push_back(meanEsum0[i]/1000);
  ErrEGeV0.push_back(ErrE0[i]/1000);
}

vector<double> mEGeV1; mEGeV1.reserve(size(meanEsum1));
vector<double> ErrEGeV1; ErrEGeV1.reserve(size(meanEsum1));
for (int i=0; i<=size(meanEsum1); i++)
{
  mEGeV1.push_back(meanEsum1[i]/1000);
  ErrEGeV1.push_back(ErrE1[i]/1000);
}
  auto gr3 = new TGraphErrors(N,coref.data(),mEGeV0.data(),0,ErrEGeV0.data());
  gr3->SetTitle(title + "; Thickness of Magnet Core / mm; Mean Bunch Energy / GeV ");
  gr3->SetMarkerColor(4);
  gr3->SetMarkerStyle(21);
  gr3->Draw("ALP");
  gr3->GetXaxis()->SetLabelSize(0.04);
  gr3->GetYaxis()->SetLabelSize(0.04);
  auto gr4 = new TGraphErrors(N,coref.data(),mEGeV1.data(),0,ErrEGeV1.data());
  gr4->SetMarkerColor(6);
  gr4->SetMarkerStyle(21);
  gr4->SetLineStyle(7);
  gr4->Draw("LPSAME");
  c2->SetLogy();

  //draw legend
  auto legend = new TLegend(0.5,0.75,0.9,0.9);
  //legend->SetHeader("The Legend Title","C"); // option "C" allows to center the header
  legend->AddEntry(gr3,"Parallel Polarization","l");
  legend->AddEntry(gr4,"Antiparallel Polarization","l");
  legend->Draw();

  c2->SaveAs("./plots/core_run_BunchE.svg");
  c2->SaveAs("./plots/core_run_BunchE.pdf");
}

void plot_Erun(const vector<string> &E,const  vector<string> &core,
                  const vector<string> &conv, const string &NBunch,
                  const vector<double> &meanEsum0,const vector<double> &meanEsum1,
                  const vector<double> &ErrE0, const vector<double> &ErrE1,
                  const vector<double> &Asy, const vector<double> &ErrAsy,
                  const vector<double> &rate, const vector<double> &ErrRate){
  //------ooooooo-------0000000--------oooooo-------0000000------oooooo---------
  //          Draw Asymmetry
  //------ooooooo-------0000000--------oooooo-------0000000------oooooo---------
  //Get double vector from string vector
  auto Ef=StringVec2DoubleVec(E);
  int N=size(Ef);
  gStyle->SetGridColor(17);
  gStyle->SetEndErrorSize(4);
  gStyle->SetTitleSize(0.04,"xyz");
  gStyle->SetTitleSize(0.05,"xyz");
  //create canvas
  auto c1 = new TCanvas("c1","gerrors2",200,10,700,500);

  TPad *pad = new TPad("pad","",0,0,1,1);
  pad->SetFillColor(0);
  pad->SetGrid();
  pad->SetRightMargin(0.09);
  pad->SetLeftMargin(0.15);
  pad->SetBottomMargin(0.15);
  pad->Draw();
  pad->cd();
  // draw a frame to define the range
  auto *hr = pad->DrawFrame(0,
                            0,
                            *max_element(Ef.begin(),Ef.end())+5,
                            *max_element(Asy.begin(),Asy.end())*1.1);
  hr->GetXaxis()->SetLabelSize(0.04);
  hr->GetYaxis()->SetLabelSize(0.04);
  pad->GetFrame()->SetFillColor(0);
  pad->GetFrame()->SetBorderSize(12);
  auto gr = new TGraphErrors(N,Ef.data(),Asy.data(),0,ErrAsy.data());
  TString title=string("N_{e}/Bunch=")+NBunch+", conv="+conv[0]+"mm, core="+core[0]+ "mm;Energy of incident Electrons / MeV;Transmission Asymmetry /%";
  hr->SetTitle(title);
	gr->SetMarkerColor(4);
	gr->SetMarkerStyle(21);
	gr->Draw("LP");
  TString fname1=string("./plots/E_run_Asy_core_"+core[0]+"mm.pdf");
  TString fname2=string("./plots/E_run_Asy_core_"+core[0]+"mm.svg");
  c1->SaveAs(fname1);
  c1->SaveAs(fname2);
}

void plot_convRun(const vector<string> &E,const  vector<string> &core,
                  const vector<string> &conv, const string &NBunch,
                  const vector<double> &meanEsum0,const vector<double> &meanEsum1,
                  const vector<double> &ErrE0, const vector<double> &ErrE1,
                  const vector<double> &Asy, const vector<double> &ErrAsy,
                  const vector<double> &rate, const vector<double> &ErrRate){
  //------ooooooo-------0000000--------oooooo-------0000000------oooooo---------
  //          Draw Asymmetry
  //------ooooooo-------0000000--------oooooo-------0000000------oooooo---------
  //Get double vector from string vector
  auto convf=StringVec2DoubleVec(conv);
  int N=size(convf);
  //create canvas
  auto c1 = new TCanvas("c1","gerrors2",200,10,700,500);
  TPad *pad = new TPad("pad","",0,0,1,1);
  pad->SetFillColor(0);
  pad->SetGrid();
  pad->Draw();
  pad->cd();
  auto gr = new TGraphErrors(N,convf.data(),Asy.data(),0,ErrAsy.data());
	TString title=string("N_{e}/Bunch=")+NBunch+", E_{beam}="+E[0]+"MeV, core="+core[0]+ "mm;"
                + "Converter Target thickness / mm; Transmission Asymmetry /%";
	gr->SetTitle(title);
	gr->SetMarkerColor(4);
	gr->SetMarkerStyle(25);
	gr->Draw("ALP");

  c1->SaveAs("./plots/conv_run_Asy.eps");
  c1->SaveAs("./plots/conv_run_Asy.pdf");

  //create canvas
  auto c2 = new TCanvas("c1","gerrors2",200,10,700,500);
  TPad *pad2 = new TPad("pad","",0,0,1,1);
  pad2->SetFillColor(0);
  pad2->SetGrid();
  pad2->Draw();
  pad2->cd();
  auto gr2 = new TGraphErrors(N,convf.data(),rate.data(),0,ErrRate.data());
  TString title2=string("N_{e}/Bunch=")+NBunch+", E_{beam}="+E[0]+"MeV, core="+core[0]+ "mm;"
                + "Converter Target Thickness / mm; Photons per e- Bunch";
	gr2->SetTitle(title2);
	gr2->SetMarkerColor(4);
	gr2->SetMarkerStyle(25);
	gr2->Draw("ALP");

  c2->SaveAs("./plots/conv_run_rate.eps");
  c2->SaveAs("./plots/conv_run_rate.pdf");

}

int asy_ana2(){
  //vector<string> E={"1","2","3","5","7","10","15","20","30","40","50","60","80","100","120"};
  vector<string> E={"5","7","10","15","20","30","40","50","60","80","100","120"};
  //vector<string> E={"60"};
  //vector<string> core={"50","75","100","125","150","175","200","225","250","275","300"};
  vector<string> core={"75"};
  //vector<string> conv={"0.5","1","1.5","1.75","2","2.5","3","3.5","4","4.5"};
  vector<string> conv={"1.75"};
  string NBunch = "100000";

  // Declare vectors needed for each iteration
  vector<double> Esum0;
  vector<double> Esum1;
  vector<int> NP0;
  vector<int> NP1;
  // declare vectors needed to save run results
  vector<double> meanEsum0;
  vector<double> meanEsum1;
  vector<double> ErrE0;
  vector<double> ErrE1;
  vector<double> Asy;
  vector<double> ErrAsy;
  vector<double> rate;
  vector<int> NP01;
  vector<double>ErrRate;


//pair<double, int> p;

  string dirName="./results/";
string s0;
string s1;
double StdDevE0,StdDevE1;
vector<string>loopvar;
if(size(E)>1 &&  size(core)==1 && size(conv)==1){
  loopvar=E;
  cout<<"Start E Run:"<<endl;
}
else if(size(E)==1 &&  size(core)>1 && size(conv)==1){
  loopvar=core;
  cout<<"Start Core Thickness  Run:"<<endl;
}
else if(size(E)==1 &&  size(core)==1 && size(conv)>1){
   loopvar=conv;
   cout<<"Start Converter Target Thickness Run:"<<endl;
}
else {
loopvar=core;
cout<<"Start Core Thickness  Run:"<<endl;
}
for(int i=0;i<size(loopvar);i++){
//for(int i=1;i<2;i++){
    if(size(E)>1 &&  size(core)==1 && size(conv)==1){
       s0 = string("run0_")+"NBunch_"+NBunch+"_conv_"+conv[0]
                      +"mm_core_"+core[0]+"mm_E_" + E[i] + "MeV_PrId";

       s1 = string("run1_")+"NBunch_"+NBunch+"_conv_"+conv[0]
                     +"mm_core_"+core[0]+"mm_E_" + E[i] + "MeV_PrId";
    }
    else if(size(E)==1 &&  size(core)>1 && size(conv)==1){
       s0 = string("run0_")+"NBunch_"+NBunch+"_conv_"+conv[0]
                      +"mm_core_"+core[i]+"mm_E_" + E[0] + "MeV_PrId";

       s1 = string("run1_")+"NBunch_"+NBunch+"_conv_"+conv[0]
                     +"mm_core_"+core[i]+"mm_E_" + E[0] + "MeV_PrId";
    }
    else if(size(E)==1 &&  size(core)==1 && size(conv)>1){
       s0 = string("run0_")+"NBunch_"+NBunch+"_conv_"+conv[i]
                      +"mm_core_"+core[0]+"mm_E_" + E[0] + "MeV_PrId";

       s1 = string("run1_")+"NBunch_"+NBunch+"_conv_"+conv[i]
                     +"mm_core_"+core[0]+"mm_E_" + E[0] + "MeV_PrId";
    }
    else if(size(E)==1 &&  size(core)==1 && size(conv)==1){
       s0 = string("run0_")+"NBunch_"+NBunch+"_conv_"+conv[0]
                      +"mm_core_"+core[0]+"mm_E_" + E[0] + "MeV_PrId";

       s1 = string("run1_")+"NBunch_"+NBunch+"_conv_"+conv[0]
                     +"mm_core_"+core[0]+"mm_E_" + E[0] + "MeV_PrId";
    }

    auto flist0 = get_fnames(dirName.c_str(),s0);
    auto flist1 = get_fnames(dirName.c_str(),s1);

    cout<<"length flist0: "<<size(flist0) << endl;

    TString name0;
    TString name1;

    //loop over files to get Esum and number of photons
    for (int j=0; j<size(flist0);j++){
      //cout << "flist0[" << j <<"]: "<< flist0[j] << endl;
      name0 = dirName + flist0[j];
      name1 = dirName + flist1[j];

      auto p=read_files(name0);
      Esum0.insert(Esum0.end(), p.first.begin(), p.first.end());
      NP0.insert(NP0.end(), p.first.begin(), p.first.end());

      p=read_files(name1);
      Esum1.insert(Esum1.end(), p.first.begin(), p.first.end());
      NP1.insert(NP1.end(), p.first.begin(), p.first.end());
    }

    //plot_Esum(Esum0, Esum1);

    meanEsum0.push_back(TMath::Mean(Esum0.begin(), Esum0.end()));
    meanEsum1.push_back(TMath::Mean(Esum1.begin(), Esum1.end()));
    StdDevE0=TMath::StdDev(Esum0.begin(), Esum0.end());
    StdDevE1=TMath::StdDev(Esum1.begin(), Esum1.end());
    ErrE0.push_back(StdDevE0/sqrt(size(Esum0)));
    ErrE1.push_back(StdDevE1/sqrt(size(Esum1)));

    Asy.push_back((meanEsum0[i]-meanEsum1[i])/(meanEsum1[i]+meanEsum0[i])*100);
    //ErrAsy.push_back(2/((meanEsum1[i]+meanEsum0[i])*(meanEsum1[i]+meanEsum0[i]))
    //                * sqrt(((meanEsum0[i]*ErrE1[i])*(meanEsum0[i]*ErrE1[i]))
    //                +((meanEsum1[i]*ErrE0[i])*(meanEsum1[i]*ErrE0[i])))*100);

    ErrAsy.push_back(2/(TMath::Power(meanEsum1[i]+meanEsum0[i],2))
                    *sqrt(TMath::Power(meanEsum0[i]*ErrE1[i],2)+
                  +TMath::Power(meanEsum1[i]*ErrE0[i],2))*100);
    // mean number of photons per electron bunch_ antiparallel polarization
    NP01.insert(NP01.end(), NP0.begin(), NP0.end());
    NP01.insert(NP01.end(), NP1.begin(), NP1.end());
    //rate.push_back((TMath::Mean(NP0.begin(), NP0.end())
      //            +TMath::Mean(NP1.begin(), NP1.end()))/2);
    rate.push_back(TMath::Mean(NP01.begin(),NP01.end()));
    ErrRate.push_back(TMath::StdDev(NP01.begin(), NP01.end())/sqrt(size(NP01)));

    cout<<"Asy: "<< Asy[i]<<"%"<< endl;
    cout<<"ErrAsy: "<<ErrAsy[i]<<"%"<<endl;

    if (Asy[i]!=Asy[i]|| ErrAsy[i] != ErrAsy[i]){
      Asy[i]=0;
      ErrAsy[i]=0;
    }

    //clear vectors for next iteration
    Esum0.clear();
    Esum1.clear();
    NP0.clear();
    NP1.clear();

  }
// plot results
  if(size(E)==1 &&  size(core)>1 && size(conv)==1){
    plot_corerun( E, core, conv, NBunch,meanEsum0, meanEsum1,ErrE0,  ErrE1,  Asy,
                  ErrAsy, rate, ErrRate);
  }
  else if(size(E)>1 &&  size(core)==1 && size(conv)==1){
    plot_Erun( E, core, conv, NBunch,meanEsum0, meanEsum1,ErrE0,  ErrE1,  Asy,
                  ErrAsy, rate, ErrRate);
  }
  else if(size(E)==1 &&  size(core)==1 && size(conv)>1){
    plot_convRun( E, core, conv, NBunch,meanEsum0, meanEsum1,ErrE0,  ErrE1,  Asy,
                  ErrAsy, rate, ErrRate);
  }
  return 0;
}
